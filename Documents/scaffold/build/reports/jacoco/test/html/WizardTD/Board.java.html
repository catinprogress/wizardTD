<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Board.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">scaffold</a> &gt; <a href="index.source.html" class="el_package">WizardTD</a> &gt; <span class="el_source">Board.java</span></div><h1>Board.java</h1><pre class="source lang-java linenums">package WizardTD;

import processing.core.PApplet;
import processing.core.PImage;
import java.util.*;
import processing.data.JSONObject;
import java.awt.Graphics2D;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;

public class Board extends GameElements {
    private int initial_x; 
    private int initial_y;
    private int wizard_i;
    private int wizard_j;

    private PImage grass;
    private PImage shrub;
    private PImage horizontal_path;
    private PImage vertical_path;
    private PImage right_down_path;
    private PImage right_up_path;
    private PImage left_down_path;
    private PImage left_up_path;
    private PImage cross_path;
    private PImage t_path;
    private PImage flipped_t_path;
    private PImage right_t_path;
    private PImage left_t_path;
    private PImage wizard_house;

    private int[][][] tile_coords;
    private int[][] path_array;
    private HashMap&lt;int[], PImage&gt; paths;
    private HashMap&lt;int[], PImage&gt; elements;
    private int[] wizard_coords;
    private ArrayList&lt;ArrayList&lt;int[]&gt;&gt; all_valid_paths;

    public Board(PApplet app, PImage grass, PImage shrub, PImage horizontal_path, PImage right_down_path, PImage cross_path, PImage t_path, PImage wizard_house, JSONObject json, int height){
<span class="fc" id="L40">        super(json);</span>
<span class="fc" id="L41">        initial_x = 0;</span>
<span class="fc" id="L42">        initial_y = height - BOARD_WIDTH*PIXELSPERTILE;</span>

<span class="fc" id="L44">        this.grass = grass;</span>
<span class="fc" id="L45">        this.shrub = shrub;</span>
<span class="fc" id="L46">        this.wizard_house = wizard_house;</span>

<span class="fc" id="L48">        this.horizontal_path = horizontal_path;</span>
<span class="fc" id="L49">        vertical_path = rotateImageByDegrees(horizontal_path, 90, app);</span>

<span class="fc" id="L51">        this.right_down_path = right_down_path;</span>
<span class="fc" id="L52">        right_up_path = rotateImageByDegrees(right_down_path, 90, app);</span>
<span class="fc" id="L53">        left_up_path = rotateImageByDegrees(right_down_path, 180, app);</span>
<span class="fc" id="L54">        left_down_path = rotateImageByDegrees(right_down_path, 270, app);</span>

<span class="fc" id="L56">        this.cross_path = cross_path;</span>

<span class="fc" id="L58">        this.t_path = t_path;</span>
<span class="fc" id="L59">        flipped_t_path = rotateImageByDegrees(t_path, 180, app);</span>
<span class="fc" id="L60">        right_t_path = rotateImageByDegrees(t_path, 90, app);</span>
<span class="fc" id="L61">        left_t_path = rotateImageByDegrees(t_path, 270, app);</span>
 
<span class="fc" id="L63">        tile_coords = setCoords();</span>
<span class="fc" id="L64">        path_array = set2DPathArray();</span>
<span class="fc" id="L65">        wizard_coords = getWizardHouse();</span>
<span class="fc" id="L66">        paths = getPaths(app);</span>
<span class="fc" id="L67">        elements = getElements();</span>
<span class="fc" id="L68">        all_valid_paths = findShortestPathstoFollow();</span>
<span class="fc" id="L69">    }</span>

     /**
     * Source: https://stackoverflow.com/questions/37758061/rotate-a-buffered-image-in-java
     * @param pimg The image to be rotated
     * @param angle between 0 and 360 degrees
     * @return the new rotated image
     */
    public PImage rotateImageByDegrees(PImage pimg, double angle, PApplet app) {
<span class="fc" id="L78">        BufferedImage img = (BufferedImage) pimg.getNative();</span>
<span class="fc" id="L79">        double rads = Math.toRadians(angle);</span>
<span class="fc" id="L80">        double sin = Math.abs(Math.sin(rads)), cos = Math.abs(Math.cos(rads));</span>
<span class="fc" id="L81">        int w = img.getWidth();</span>
<span class="fc" id="L82">        int h = img.getHeight();</span>
<span class="fc" id="L83">        int newWidth = (int) Math.floor(w * cos + h * sin);</span>
<span class="fc" id="L84">        int newHeight = (int) Math.floor(h * cos + w * sin);</span>

<span class="fc" id="L86">        PImage result = app.createImage(newWidth, newHeight, PApplet.RGB);</span>
        //BufferedImage rotated = new BufferedImage(newWidth, newHeight, BufferedImage.TYPE_INT_ARGB);
<span class="fc" id="L88">        BufferedImage rotated = (BufferedImage) result.getNative();</span>
<span class="fc" id="L89">        Graphics2D g2d = rotated.createGraphics();</span>
<span class="fc" id="L90">        AffineTransform at = new AffineTransform();</span>
<span class="fc" id="L91">        at.translate((newWidth - w) / 2, (newHeight - h) / 2);</span>

<span class="fc" id="L93">        int x = w / 2;</span>
<span class="fc" id="L94">        int y = h / 2;</span>

<span class="fc" id="L96">        at.rotate(rads, x, y);</span>
<span class="fc" id="L97">        g2d.setTransform(at);</span>
<span class="fc" id="L98">        g2d.drawImage(img, 0, 0, null);</span>
<span class="fc" id="L99">        g2d.dispose();</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">        for (int i = 0; i &lt; newWidth; i++) {</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">            for (int j = 0; j &lt; newHeight; j++) {</span>
<span class="fc" id="L102">                result.set(i, j, rotated.getRGB(i, j));</span>
            }
        }

<span class="fc" id="L106">        return result;</span>
    }
        
    /**
     * Calculates the leftmost x,y pixel coordinates of each tile on the board, according to their respective row and column position
     * row and column number is relative to board width
     * x, y coordinate depends on the number of pixels per tile
     * @return coord_array
     */
    private int[][][] setCoords() {
<span class="fc" id="L116">        int[][][] coord_array = new int[BOARD_WIDTH][BOARD_WIDTH][2];</span>
        int x;
        int y;

<span class="fc bfc" id="L120" title="All 2 branches covered.">        for (int i = 0; i &lt; BOARD_WIDTH; i++) {</span>
<span class="fc" id="L121">            y = initial_y + (PIXELSPERTILE*i);</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">            for (int j = 0; j &lt; BOARD_WIDTH; j++) {</span>
<span class="fc" id="L123">                x = initial_x + (PIXELSPERTILE*j);  </span>
<span class="fc" id="L124">                coord_array[i][j][0] = x;</span>
<span class="fc" id="L125">                coord_array[i][j][1] = y;</span>

            }    
        } 
<span class="fc" id="L129">        return coord_array;</span>
    }

    /**
     * Creates a 2D array to determine the location of a path tile
     * path or wizard house represented by the value 0
     * all other path elements represented by the value 1
     * @return path_array
     */
    private int[][] set2DPathArray() {
<span class="fc" id="L139">        int[][] path_array = new int[BOARD_WIDTH][BOARD_WIDTH];</span>

<span class="fc bfc" id="L141" title="All 2 branches covered.">        for (int i = 0; i &lt; BOARD_WIDTH; i++) {</span>
<span class="fc" id="L142">            String line = getMap().get(i); //get ith row in map</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">            for (int j = 0; j &lt; BOARD_WIDTH; j++) { //get jth column in map</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">                if (line.charAt(j) == 'X') { </span>
<span class="fc" id="L145">                    path_array[i][j] = 0;</span>
                }
<span class="fc bfc" id="L147" title="All 2 branches covered.">                else if (line.charAt(j) == 'W') {</span>
<span class="fc" id="L148">                    path_array[i][j] = 0;</span>
<span class="fc" id="L149">                    wizard_i = i;</span>
<span class="fc" id="L150">                    wizard_j = j;</span>
                }

                else {
<span class="fc" id="L154">                    path_array[i][j] = 1;</span>
                }
            }
        }
<span class="fc" id="L158">        return path_array;</span>
    }

    /**
     * Creates an ArrayList containing the leftmost x, y pixel coordinates of each grass tile on the board
     * @return grass_tile_coords
     */
    public ArrayList&lt;int[]&gt; getGrassTiles() {
<span class="fc" id="L166">        ArrayList&lt;int[]&gt; grass_tiles_coords = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L168" title="All 2 branches covered.">        for (int i = 0; i &lt; BOARD_WIDTH; i++) {</span>
<span class="fc" id="L169">            String line = getMap().get(i); //get ith row in map</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">            for (int j = 0; j &lt; BOARD_WIDTH; j++) { //get jth column in map</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">                if (line.charAt(j) == ' ') { </span>
<span class="fc" id="L172">                    int[] coords = {tile_coords[i][j][0], tile_coords[i][j][1]};</span>
<span class="fc" id="L173">                    grass_tiles_coords.add(coords);</span>
                }
            }
        }
<span class="fc" id="L177">        return grass_tiles_coords;</span>
    }

    /**
     * Creates an ArrayList containing the leftmost x, y pixel coordinates of each grass tile on the board
     * @return grass_tile_coords
     */
    public ArrayList&lt;int[]&gt; getPathTiles() {
<span class="fc" id="L185">        ArrayList&lt;int[]&gt; path_tiles_coords = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L187" title="All 2 branches covered.">        for (int i = 0; i &lt; BOARD_WIDTH; i++) {</span>
<span class="fc" id="L188">            String line = getMap().get(i); //get ith row in map</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">            for (int j = 0; j &lt; BOARD_WIDTH; j++) { //get jth column in map</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">                if (line.charAt(j) == 'X') { </span>
<span class="fc" id="L191">                    int[] coords = {tile_coords[i][j][0], tile_coords[i][j][1]};</span>
<span class="fc" id="L192">                    path_tiles_coords.add(coords);</span>
                }
            }
        }
<span class="fc" id="L196">        return path_tiles_coords;</span>
    }

    /**
     * Finds the x, y pixel coordinates of the wizard house
     * calculates the coordinate offset for centering the wizard house on its tile
     * @return coords
     */
    private int[] getWizardHouse() {
<span class="fc" id="L205">        int[] coords = new int[2];</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">        for (int i = 0; i &lt; BOARD_WIDTH; i++) { //get rows in map</span>
<span class="fc" id="L207">            String line = this.getMap().get(i); //current line in map</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">            for (int j = 0; j &lt; BOARD_WIDTH; j++) { //get column in map</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">                if (line.charAt(j) == 'W') {</span>
<span class="fc" id="L210">                    coords[0] = tile_coords[i][j][0] - 8;</span>
<span class="fc" id="L211">                    coords[1] = tile_coords[i][j][1] - 8;</span>
                }
            }
        }
<span class="fc" id="L215">        return coords;</span>
    }

    /**
     * Renders the image of each tile onto the screen at their respective coordinates
     * @param app that instantiates this class
     */
    public void draw(PApplet app) {
<span class="fc bfc" id="L223" title="All 2 branches covered.">        for (Map.Entry&lt;int[], PImage&gt; entry: paths.entrySet()) {</span>
<span class="fc" id="L224">            int[] coords = entry.getKey();</span>
<span class="fc" id="L225">            app.image(entry.getValue(), coords[0], coords[1]);</span>
<span class="fc" id="L226">        }</span>

<span class="fc bfc" id="L228" title="All 2 branches covered.">        for (Map.Entry&lt;int[], PImage&gt; entry: elements.entrySet()) {</span>
<span class="fc" id="L229">            int[] coords = entry.getKey();</span>
<span class="fc" id="L230">            app.image(entry.getValue(), coords[0], coords[1]);</span>
<span class="fc" id="L231">        }        </span>
<span class="fc" id="L232">    }  </span>

    public void drawWizard(PApplet app) {
<span class="fc" id="L235">        app.image(this.wizard_house, wizard_coords[0], wizard_coords[1]);</span>
<span class="fc" id="L236">    }</span>
    
    /**
     * Creates hashmap that maps a path PImage to their respective path coordinate
     * Path image to put is calculated by neighbouring tiles and whether they are paths or not 
     * @param app that instantiantes this class
     * @return path_map
     */
    private HashMap&lt;int[], PImage&gt; getPaths(PApplet app) {
<span class="fc" id="L245">        HashMap&lt;int[], PImage&gt; path_map = new HashMap&lt;int[], PImage&gt;();</span>

<span class="fc bfc" id="L247" title="All 2 branches covered.">        for (int i = 1; i &lt; BOARD_WIDTH-1; i++) { //get path images for centre of map</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">            for (int j = 1; j &lt; BOARD_WIDTH-1; j++) {               </span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">                if (path_array[i][j] == 0) {</span>
<span class="fc" id="L250">                    PImage to_put = new PImage();</span>
<span class="fc bfc" id="L251" title="All 6 branches covered.">                    if (path_array[i-1][j] == 1 &amp; path_array[i+1][j] == 1) { //i-1 = row above, i+1 = row below</span>
<span class="fc" id="L252">                        to_put = horizontal_path;</span>
                    }
<span class="fc bfc" id="L254" title="All 6 branches covered.">                    else if (path_array[i-1][j] == 0 &amp; path_array[i+1][j] == 0) {</span>
<span class="fc bfc" id="L255" title="All 6 branches covered.">                        if (path_array[i][j+1] == 1 &amp; path_array[i][j-1] == 1) { //j+1 = column to right, j-1 = column to left</span>
<span class="fc" id="L256">                            to_put = vertical_path;</span>
                        }
<span class="pc bpc" id="L258" title="1 of 6 branches missed.">                        else if (path_array[i][j+1] == 1 &amp; path_array[i][j-1] == 0) {</span>
<span class="fc" id="L259">                            to_put = right_t_path;</span>
                        }
<span class="pc bpc" id="L261" title="3 of 6 branches missed.">                        else if (path_array[i][j+1] == 0 &amp; path_array[i][j-1] == 1) {</span>
<span class="nc" id="L262">                            to_put = left_t_path;</span>
                        }
                        else {
<span class="fc" id="L265">                            to_put = cross_path;</span>
                       }
                    }
<span class="fc bfc" id="L268" title="All 6 branches covered.">                    else if (path_array[i-1][j] == 1 &amp; path_array[i+1][j] == 0) {</span>
<span class="pc bpc" id="L269" title="1 of 6 branches missed.">                        if (path_array[i][j+1] == 1 &amp; path_array[i][j-1] == 1) {</span>
<span class="nc" id="L270">                            to_put = vertical_path;</span>
                        }
<span class="fc bfc" id="L272" title="All 6 branches covered.">                        else if (path_array[i][j+1] == 1 &amp; path_array[i][j-1] == 0) {</span>
<span class="fc" id="L273">                            to_put = right_down_path;</span>
                        }
<span class="pc bpc" id="L275" title="3 of 6 branches missed.">                        else if (path_array[i][j+1] == 0 &amp; path_array[i][j-1] == 1) {</span>
<span class="fc" id="L276">                            to_put = left_down_path;</span>
                        }
                        else {
<span class="nc" id="L279">                            to_put = t_path;</span>
                        }   
                    }
                    else {
<span class="fc bfc" id="L283" title="All 6 branches covered.">                        if (path_array[i][j+1] == 1 &amp; path_array[i][j-1] == 1) {</span>
<span class="fc" id="L284">                            to_put = vertical_path;</span>
                        }
<span class="pc bpc" id="L286" title="1 of 6 branches missed.">                        else if (path_array[i][j+1] == 1 &amp; path_array[i][j-1] == 0) {</span>
<span class="fc" id="L287">                            to_put = right_up_path;</span>
                        }
<span class="pc bpc" id="L289" title="3 of 6 branches missed.">                        else if (path_array[i][j+1] == 0 &amp; path_array[i][j-1] == 1) {</span>
<span class="nc" id="L290">                            to_put = left_up_path;</span>
                        }
                        else {
<span class="fc" id="L293">                            to_put = flipped_t_path;</span>
                        }
                    
                    } 
                    
<span class="fc" id="L298">                    path_map.put(tile_coords[i][j], to_put);</span>
                }
            }
        }

        //get edges of board
<span class="fc bfc" id="L304" title="All 2 branches covered.">        for (int j = 1; j &lt; BOARD_WIDTH; j++) {</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">            if (path_array[0][j] == 0) {</span>
<span class="fc" id="L306">                PImage to_put = getBorderRows(path_array[0], true, path_array[1], j, app);</span>
<span class="fc" id="L307">                path_map.put(tile_coords[0][j], to_put);</span>
            }

<span class="fc bfc" id="L310" title="All 2 branches covered.">            if (path_array[BOARD_WIDTH-1][j] == 0) {</span>
<span class="fc" id="L311">                PImage to_put = getBorderRows(path_array[BOARD_WIDTH-1], false, path_array[BOARD_WIDTH-2], j, app);</span>
<span class="fc" id="L312">                path_map.put(tile_coords[BOARD_WIDTH-1][j], to_put);</span>
            }

<span class="pc bpc" id="L315" title="1 of 2 branches missed.">            if (path_array[j][0] == 0) {</span>
<span class="nc" id="L316">                PImage to_put = getBorderColumns(path_array, 0, j, 1, true, app);</span>
<span class="nc" id="L317">                path_map.put(tile_coords[j][0], to_put);</span>
            }        

<span class="fc bfc" id="L320" title="All 2 branches covered.">            if (path_array[j][BOARD_WIDTH-1] == 0) {</span>
<span class="fc" id="L321">                PImage to_put = getBorderColumns(path_array, BOARD_WIDTH-1, j, -1, false, app);</span>
<span class="fc" id="L322">                path_map.put(tile_coords[j][BOARD_WIDTH-1], to_put);</span>
            }           
        }

<span class="fc bfc" id="L326" title="All 2 branches covered.">        for (int i = 0; i &lt; BOARD_WIDTH; i += (BOARD_WIDTH-1)) {</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">            for (int j = 0; j &lt; BOARD_WIDTH; j += (BOARD_WIDTH-1)) {</span>
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">                if (path_array[i][j] == 0) {</span>
<span class="nc" id="L329">                    path_map.put(tile_coords[i][j], cross_path);</span>
                }
            }
        }

<span class="fc" id="L334">        return path_map;</span>
    }

    /**
     * Retrieves the path image to place on the top and bottom edges of the board
     * @param row coordinates of each tile in the row
     * @param is_top boolean value of whether row is top or bottom
     * @param row_below coordinates of adjacent row
     * @param column_index index of column at the given row coordinate
     * @param app that instantiates this class
     * @return the path PImage to place
     * 
     */
    private PImage getBorderRows(int[] row, boolean is_top, int[] row_below, int column_index, PApplet app) {
<span class="fc" id="L348">        PImage to_put = new PImage();</span>
<span class="fc" id="L349">        int rotate_by = 0;</span>
<span class="pc bpc" id="L350" title="3 of 6 branches missed.">        if (row[column_index+1] == 1 &amp; row[column_index-1] == 1) {</span>
<span class="fc" id="L351">            to_put = vertical_path;      </span>
        }
<span class="nc bnc" id="L353" title="All 6 branches missed.">        else if (row[column_index+1] == 0 &amp; row[column_index-1] == 0) {</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">            if (row_below[column_index] == 0) {</span>
<span class="nc" id="L355">                to_put = cross_path;</span>
            }
            else {
<span class="nc" id="L358">                to_put = flipped_t_path;</span>
<span class="nc" id="L359">                rotate_by = 180;</span>
            }
        }
<span class="nc bnc" id="L362" title="All 6 branches missed.">        else if (row[column_index+1] == 0 &amp; row[column_index-1] == 1) {</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">            if (row_below[column_index] == 0) {</span>
<span class="nc" id="L364">                to_put = left_t_path;</span>
<span class="nc" id="L365">                rotate_by = 90;</span>
            }
            else {
<span class="nc" id="L368">                to_put = left_up_path;</span>
<span class="nc" id="L369">                rotate_by = 90;</span>
            }
        }
<span class="nc bnc" id="L372" title="All 2 branches missed.">        else if (row_below[column_index] == 0) {</span>
<span class="nc" id="L373">                to_put = right_t_path;</span>
        }
        else {
<span class="nc" id="L376">            to_put = right_up_path;</span>
        }
        
<span class="fc bfc" id="L379" title="All 2 branches covered.">        if (is_top) {</span>
<span class="fc" id="L380">            return to_put;</span>
        }
<span class="fc" id="L382">        return rotateImageByDegrees(to_put, rotate_by, app);</span>
        
    }

    /**
     * Retrieves the path image to place on the left and right edges of the board
     * @param column 2D path array that indicates paths as 0
     * @param column_num y position of current coordinate
     * @param row_index x position of current row
     * @param adjacent_column index of adjacent column
     * @param is_left boolean value of whether column is on the left or right edge
     * @param app that instantiates the class
     * @return the path PImage to place
     */

    //get the images to put on the left and right edges of the board
     private PImage getBorderColumns(int[][] column, int column_num, int row_index, int adjacent_column, boolean is_left, PApplet app) {
<span class="fc" id="L399">        PImage to_put = new PImage();</span>
<span class="fc" id="L400">        int rotate_by = 0;</span>
        
<span class="pc bpc" id="L402" title="3 of 6 branches missed.">        if (column[row_index-1][column_num] == 1 &amp; column[row_index+1][column_num] == 1) {</span>
<span class="fc" id="L403">            to_put = horizontal_path;     </span>
        }
<span class="nc bnc" id="L405" title="All 6 branches missed.">        else if (column[row_index-1][column_num] == 0 &amp; column[row_index+1][column_num] == 0) {</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">            if (column[row_index][column_num+adjacent_column] == 0) {</span>
<span class="nc" id="L407">                to_put = cross_path;</span>
            }
            else {
<span class="nc" id="L410">                to_put = right_t_path; //180</span>
<span class="nc" id="L411">                rotate_by = 180;</span>
            }  
        }
<span class="nc bnc" id="L414" title="All 6 branches missed.">        else if (column[row_index-1][column_num] == 0 &amp; column[row_index+1][column_num] == 1) {</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">            if (column[row_index][column_num+adjacent_column] == 0) {</span>
<span class="nc" id="L416">                to_put = flipped_t_path;</span>
            }
            else {
<span class="nc" id="L419">                to_put = right_up_path; //90</span>
<span class="nc" id="L420">                rotate_by = 90;</span>
            }
        }
<span class="nc bnc" id="L423" title="All 6 branches missed.">        else if (column[row_index-1][column_num] == 1 &amp; column[row_index+1][column_num] == 0) {</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">            if (column[row_index][column_num+adjacent_column] == 0) {</span>
<span class="nc" id="L425">                to_put = t_path;</span>
            }
            else {
<span class="nc" id="L428">                to_put = right_down_path; //270</span>
<span class="nc" id="L429">                rotate_by = 270;</span>
            }
        }

<span class="pc bpc" id="L433" title="1 of 2 branches missed.">        if (is_left) {</span>
<span class="nc" id="L434">            return to_put;</span>
        }
<span class="fc" id="L436">        return rotateImageByDegrees(to_put, rotate_by, app);</span>
    }

    /**
     * Creates a hashmap that maps the PImage of all grass and shrub tiles to their respective x,y pixel coordinates
     * @return elements_map
     */
    private HashMap&lt;int[], PImage&gt; getElements() {
<span class="fc" id="L444">        HashMap&lt;int[], PImage&gt; elements_map = new HashMap&lt;int[], PImage&gt;();</span>

<span class="fc bfc" id="L446" title="All 2 branches covered.">        for (int i = 0; i &lt; BOARD_WIDTH; i++) { //get rows in map</span>
<span class="fc" id="L447">            String line = this.getMap().get(i); //current line in map</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">            for (int j = 0; j &lt; BOARD_WIDTH; j++) { //get column in map</span>
<span class="fc bfc" id="L449" title="All 4 branches covered.">                if (line.charAt(j) == ' ' || line.charAt(j) == 'W') {</span>
<span class="fc" id="L450">                    elements_map.put(tile_coords[i][j], this.grass);</span>
                }
<span class="fc bfc" id="L452" title="All 2 branches covered.">                else if (line.charAt(j) == 'S') {</span>
<span class="fc" id="L453">                    elements_map.put(tile_coords[i][j], this.shrub);</span>
                }
            }
        }
<span class="fc" id="L457">        return elements_map;</span>
    }
    
    /**
     * Retrieves an ArrayList containing coordinates of all valid monster spawn locations for a given map
     * Spawn locations are determined by whether coordinates on the edge of the map that have a connected path to the wizard's house
     * @return spawn_locations
     */
    public ArrayList&lt;int[]&gt; getSpawnLocations() {
<span class="fc" id="L466">        ArrayList&lt;int[]&gt; spawn_locations = new ArrayList&lt;int[]&gt;();</span>
<span class="fc" id="L467">        boolean[][] path_visited = new boolean[BOARD_WIDTH][BOARD_WIDTH];</span>

<span class="fc" id="L469">        findSpawnLocations(wizard_i, wizard_j, spawn_locations, path_visited);</span>
     
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">        if (spawn_locations.size() &lt; 1) {</span>
<span class="nc" id="L472">            System.err.println(&quot;No spawn locations for this level!&quot;);</span>
        }
<span class="fc" id="L474">        return spawn_locations;</span>
    }
    
    /**
     * Recursively follows all paths starting from the wizard's house to the edge of the board to find all valid spawn locations
     * Base case: reach the edge of the board
     * Recursive relation: if one of the surrounding tiles is a path
     * @param i the starting row position of the tile
     * @param j the starting column position of the tile
     * @param spawn_locations ArrayList to append valid spawn location positions
     * @param path_visited 2D array of same size as board to remember whether path was traversed already by previous method call
     */
    private void findSpawnLocations(int i, int j, ArrayList&lt;int[]&gt; spawn_locations, boolean[][] path_visited) {
<span class="pc bpc" id="L487" title="2 of 10 branches missed.">        if ((i == 0 || i == 19 || j == 0 || j == 19) &amp;&amp; path_array[i][j] == 0) { //base case = if at the edge of the board and on a path</span>
<span class="fc" id="L488">            path_visited[i][j] = true;</span>
<span class="fc" id="L489">            int[] array_coords = {i, j};</span>
<span class="fc" id="L490">            spawn_locations.add(array_coords);</span>
<span class="fc" id="L491">            return;</span>
        }
<span class="pc bpc" id="L493" title="3 of 4 branches missed.">        else if (path_array[i][j] == 0 || path_array[i][j] == 2) { //recursive relation = if current tile is a path and one of the surrounding tiles is also a path, go to the next path</span>
<span class="fc" id="L494">            path_visited[i][j] = true;</span>
<span class="fc bfc" id="L495" title="All 4 branches covered.">            if (path_array[i][j+1] == 0 &amp;&amp; !path_visited[i][j+1]) {</span>
<span class="fc" id="L496">                findSpawnLocations(i, j+1, spawn_locations, path_visited);</span>
                }
<span class="fc bfc" id="L498" title="All 4 branches covered.">            if (path_array[i][j-1] == 0 &amp;&amp; !path_visited[i][j-1]) {</span>
<span class="fc" id="L499">                findSpawnLocations(i, j-1, spawn_locations, path_visited);</span>
                }
<span class="fc bfc" id="L501" title="All 4 branches covered.">            if (path_array[i+1][j] == 0 &amp;&amp; !path_visited[i+1][j]) {</span>
<span class="fc" id="L502">                findSpawnLocations(i+1, j, spawn_locations, path_visited);                </span>
                }
<span class="fc bfc" id="L504" title="All 4 branches covered.">            if (path_array[i-1][j] == 0 &amp;&amp; !path_visited[i-1][j]) {</span>
<span class="fc" id="L505">                findSpawnLocations(i-1, j, spawn_locations, path_visited);  </span>
            }  
        }  
<span class="fc" id="L508">    }</span>
    
    /**
     * Finds the shortest path to the wizard house and stores in a nested ArrayList
     * If multiple paths of the same length are found, they are all added to the list
     * @return all_valid_paths
     */
    private ArrayList&lt;ArrayList&lt;int[]&gt;&gt; findShortestPathstoFollow() {
<span class="fc" id="L516">        ArrayList&lt;int[]&gt; spawn_locations = getSpawnLocations();</span>
<span class="fc" id="L517">        ArrayList&lt;ArrayList&lt;int[]&gt;&gt; all_valid_paths = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L518">        PathFinding.Point end = new PathFinding.Point(wizard_j, wizard_i, null);</span>
         
<span class="fc bfc" id="L520" title="All 2 branches covered.">        for (int[] location : spawn_locations) {        </span>
<span class="fc" id="L521">            PathFinding.Point start = new PathFinding.Point(location[1], location[0], null);</span>
<span class="fc" id="L522">            List&lt;PathFinding.Point&gt; path = PathFinding.FindPath(path_array, start, end);</span>

<span class="pc bpc" id="L524" title="1 of 2 branches missed.">            if (path != null) {</span>
<span class="fc" id="L525">                ArrayList&lt;int[]&gt; valid_path = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L526">                valid_path.add(tile_coords[location[0]][location[1]]);</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">                for (PathFinding.Point point : path) {</span>
<span class="fc" id="L528">                    int[] coords = tile_coords[point.y][point.x];</span>
<span class="fc" id="L529">                    valid_path.add(coords);</span>
<span class="fc" id="L530">                }</span>
<span class="fc" id="L531">                all_valid_paths.add(valid_path);</span>
            }
<span class="fc" id="L533">        }</span>

<span class="pc bpc" id="L535" title="2 of 4 branches missed.">        if (all_valid_paths.size() == 0 || all_valid_paths == null) {</span>
<span class="nc" id="L536">            System.err.println(&quot;No valid paths to follow&quot;);</span>
<span class="nc" id="L537">            System.exit(1);</span>
        }

<span class="fc" id="L540">        int smallest = all_valid_paths.get(0).size(); //get shortest path</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">        for (int i = 1; i &lt; all_valid_paths.size(); i++) {</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">            if (all_valid_paths.get(i).size() &lt; smallest) {</span>
<span class="nc" id="L543">                smallest = all_valid_paths.get(i).size();</span>
<span class="nc" id="L544">                all_valid_paths.remove(i-1);</span>
            }
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">            else if (all_valid_paths.get(i).size() &gt; smallest) {</span>
<span class="fc" id="L547">                all_valid_paths.remove(i);</span>
            }
        }
<span class="fc" id="L550">        return all_valid_paths;</span>
    }

    /**
     * Retrieves nestest ArrayList containing all shortest paths to the wizard house
     * @return all_valid_path
     */
    public ArrayList&lt;ArrayList&lt;int[]&gt;&gt; getValidPaths() {
<span class="fc" id="L558">        return all_valid_paths;</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>