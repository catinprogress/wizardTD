<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Wave.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">scaffold</a> &gt; <a href="index.source.html" class="el_package">WizardTD</a> &gt; <span class="el_source">Wave.java</span></div><h1>Wave.java</h1><pre class="source lang-java linenums">package WizardTD;

import processing.data.JSONObject;
import processing.data.JSONArray;
import processing.core.PApplet;
import processing.core.PImage;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

public class Wave extends GameElements{
    private double pre_wave_pause;
    private double duration;
    private int current_wave_number;
    private int final_wave;
    private double next_pre_wave_pause;
    private int wave_framecount;

    private int total_monsters_current_wave;
    private int total_monsters;
    private int frames_per_spawn;
    private int double_frames;
    private int frame_track;

    private ArrayList&lt;String&gt; monster_types;
    private ArrayList&lt;Monsters&gt; monsters_to_spawn;
    private ArrayList&lt;Monsters&gt; spawned_monsters;
    private ArrayList&lt;Monsters&gt; to_remove;
    private HashMap&lt;String, PImage&gt; types;

    private JSONObject current_wave;
    private JSONArray waves;
    private NextWaveText next_wave_text;
    private Mana mana;
    private Board board;
    
    private PImage death_1;
    private PImage death_2;
    private PImage death_3;
    private PImage death_4;
    private PImage death_5;

    private boolean has_won;

    public Wave(Mana mana, JSONObject json, Board board, HashMap&lt;String, PImage&gt; types, PImage death_1, PImage death_2, PImage death_3, PImage death_4, PImage death_5) {
<span class="fc" id="L47">        super(json);</span>
<span class="fc" id="L48">        this.board = board;</span>
<span class="fc" id="L49">        waves = readJSONArray(json, &quot;waves&quot;);</span>
<span class="fc" id="L50">        current_wave_number = 1;</span>
<span class="fc" id="L51">        current_wave = getCurrentWave(waves, current_wave_number);</span>
<span class="fc" id="L52">        final_wave = waves.size();</span>
<span class="fc" id="L53">        duration = getNumericAmount(&quot;duration&quot;, current_wave);</span>
<span class="fc" id="L54">        total_monsters_current_wave = getTotalMonsters(readJSONArray(current_wave, &quot;monsters&quot;));</span>
<span class="fc" id="L55">        total_monsters = total_monsters_current_wave;</span>
<span class="fc" id="L56">        pre_wave_pause = getNumericAmount(&quot;pre_wave_pause&quot;, current_wave);</span>
<span class="fc" id="L57">        this.types = types;</span>
<span class="fc" id="L58">        wave_framecount = 0;</span>
<span class="fc" id="L59">        this.mana = mana;</span>
<span class="fc" id="L60">        to_remove = new ArrayList&lt;&gt;(); </span>
<span class="fc" id="L61">        has_won = false;</span>

<span class="fc" id="L63">        this.death_1 = death_1;</span>
<span class="fc" id="L64">        this.death_2 = death_2;</span>
<span class="fc" id="L65">        this.death_3 = death_3;</span>
<span class="fc" id="L66">        this.death_4 = death_4;</span>
<span class="fc" id="L67">        this.death_5 = death_5;</span>
        
<span class="fc" id="L69">        monster_types = getMonsterTypes(readJSONArray(current_wave, &quot;monsters&quot;));</span>
<span class="fc" id="L70">        frames_per_spawn = setFramesPerSpawn(FPS);</span>
<span class="fc" id="L71">        double_frames = setFramesPerSpawn(FPS/2);</span>
<span class="fc" id="L72">        monsters_to_spawn = getMonstersToSpawn(types, board);</span>
<span class="fc" id="L73">        spawned_monsters = new ArrayList&lt;Monsters&gt;();</span>
        
<span class="fc" id="L75">        next_pre_wave_pause = getNumericAmount(&quot;pre_wave_pause&quot;, getCurrentWave(waves, current_wave_number+1));</span>
<span class="fc" id="L76">        next_wave_text = new NextWaveText((int)pre_wave_pause, waves.size());</span>
<span class="fc" id="L77">    }</span>

    /**
     * Retrieves an ArrayList containing all the monster that have been currently spawned
     * @return spawned monsters
     */
    public ArrayList&lt;Monsters&gt; getSpawnedMonsters() {
<span class="fc" id="L84">        return spawned_monsters;</span>
    }

    /**
     * Retrieves the total number of waves for this level
     * @return final_wave
     */
    public int getFinalWaveNumber() {
<span class="fc" id="L92">        return final_wave;</span>
    }

    /**
     * Calculates the number of frames in between each monster spawn, where the value depends on the duration of the wave and the total monsters to spawn
     * @param FPS frames per second
     * @return frames_per_spawn
     */
    private int setFramesPerSpawn(double FPS) {
<span class="fc" id="L101">        double seconds = duration/total_monsters_current_wave;</span>
        int frames_per_spawn;
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">        if (FPS &gt; 0) {</span>
<span class="fc" id="L104">            frames_per_spawn = (int)(seconds*FPS);</span>
        }
        else {
<span class="nc" id="L107">            frames_per_spawn = (int)(seconds*GameElements.FPS);</span>
        }

<span class="fc" id="L110">        return frames_per_spawn;</span>
    }

    /**
     * Retrieves the number of frames in between each monster spawn
     * @return frames_per_spawn
     */
    public int getFramesPerSpawn() {
<span class="fc" id="L118">        return frames_per_spawn;</span>
    }

    /**
     * Retrieves the duration of the current wave, which is the period in which monsters can be spawned
     * @return duration
     */
    public double getDuration() {
<span class="fc" id="L126">        return duration;</span>
    }

    /**
     * Retrieves total monsters that are alive currently
     * @return total_monsters
     */
    public int getTotalMonsters() {
<span class="fc" id="L134">        return total_monsters;</span>
    }

    /**
     * Retrieves total monsters that exist in the current wave, excluding those that were carried on from previous waves
     * @return total_monsters_current_wave
     */
    public int getTotalMonstersCurrentWave() {
<span class="fc" id="L142">        return total_monsters_current_wave;</span>
    }

    /**
     * Creates an ArrayList containing all the Monsters types and their quantities to spawn for the current wave
     * @param types HashMap where the PImage of a monster maps to its type indicated a String
     * @param board Board object to set valid paths for monsters to follow
     * @return monsters
     */
    private ArrayList&lt;Monsters&gt; getMonstersToSpawn(HashMap&lt;String, PImage&gt; types, Board board){
<span class="fc" id="L152">        ArrayList&lt;Monsters&gt; monsters = new ArrayList&lt;Monsters&gt;();</span>
        
<span class="fc bfc" id="L154" title="All 2 branches covered.">        for (Map.Entry&lt;String, PImage&gt; current : types.entrySet()) {</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">            if (monster_types.contains(current.getKey())) {</span>
<span class="fc" id="L156">                Monsters new_monster = new Monsters(json, board, current_wave, current.getValue(), current.getKey(), death_1, death_2, death_3, death_4, death_5);</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">                for (int i = 0; i &lt; new_monster.getQuantity(); i++) {      </span>
<span class="fc" id="L158">                    Monsters clone = new_monster.clone();</span>
<span class="fc" id="L159">                    clone.setSpawnedPath();              </span>
<span class="fc" id="L160">                    monsters.add(clone); //create new monster objects of the correct quantity</span>
                }
            }
<span class="fc" id="L163">        }</span>
<span class="fc" id="L164">        return monsters;</span>
    }

    /**
     * Allows user to spawn monster objects randomly.
     * @param monsters_to_spawn contains all monsters to spawn for a wave to remove from after they have been randomly spawned
     * @param spawned_monsters contains ArrayList of already spawned monsters to append to
     */
    private void randomMonsterSpawn(ArrayList&lt;Monsters&gt; monsters_to_spawn, ArrayList&lt;Monsters&gt; spawned_monsters) {
<span class="fc" id="L173">        int index = random.nextInt(monsters_to_spawn.size());</span>
<span class="fc" id="L174">        spawned_monsters.add(monsters_to_spawn.get(index));</span>
<span class="fc" id="L175">        monsters_to_spawn.remove(index);</span>
<span class="fc" id="L176">    }</span>

    /**
     * Logic for spawning monsters at the correct frame count and displaying them on screen if they are still alive.
     * Also shows the text that indicates the time until the next wave begins. 
     * The player can only continue to the next wave if they have enough mana remaining.
     * They can can only win the game if they get to the last wave and all monsters have been spawned and killed
     * @param app that instantiates this class
     * @param pause Pause object used to stop any movement when pause is selected
     * @param ff FastForward object used to speed up all movement when fast forward is selected
     */
    public void tick(PApplet app, Pause pause, FastFoward ff) { 
<span class="fc bfc" id="L188" title="All 4 branches covered.">        if (current_wave_number == final_wave &amp;&amp; total_monsters == 0) {</span>
<span class="fc" id="L189">            has_won = true;</span>
        }
<span class="fc bfc" id="L191" title="All 4 branches covered.">        else if (!pause.isSelected() &amp;&amp; !mana.hasLost()) {</span>
<span class="fc" id="L192">            wave_framecount++;</span>
<span class="fc" id="L193">            this.next_wave_text.tick(app);</span>
<span class="fc" id="L194">            frame_track = app.frameCount%frames_per_spawn; //track when to spawn monsters</span>
<span class="fc" id="L195">            int fps = FPS;</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">            if (ff.isSelected()) {</span>
<span class="fc" id="L197">                frame_track = app.frameCount%(double_frames);</span>
<span class="fc" id="L198">                fps = (int)(FPS/2);</span>
            }

<span class="pc bpc" id="L201" title="3 of 4 branches missed.">            if ((int)pre_wave_pause &gt; 0 &amp;&amp; wave_framecount &lt; fps*pre_wave_pause) {</span>
<span class="nc" id="L202">                pre_wave_pause--;</span>
<span class="nc" id="L203">                next_wave_text.decrement();</span>
            }
<span class="fc bfc" id="L205" title="All 4 branches covered.">            else if (pre_wave_pause &gt; 0 &amp;&amp; wave_framecount &gt;= fps*pre_wave_pause) { //first pre_wave_pause check</span>
<span class="fc" id="L206">                pre_wave_pause = 0;</span>
<span class="fc" id="L207">                this.next_wave_text.setNextWave();</span>
<span class="fc" id="L208">                this.next_wave_text.setSeconds((int)next_pre_wave_pause + (int)duration);</span>
            }
<span class="fc bfc" id="L210" title="All 4 branches covered.">            else if ((pre_wave_pause == 0) &amp;&amp; (app.frameCount%fps == 0)) {</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">                if (duration &gt; 0) {</span>
<span class="fc" id="L212">                    duration--;</span>
                }
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">                else if (next_pre_wave_pause &gt; 0 ) {</span>
<span class="fc" id="L215">                    next_pre_wave_pause--;</span>
                }
<span class="fc" id="L217">                next_wave_text.decrement();</span>
            }

<span class="fc bfc" id="L220" title="All 4 branches covered.">            if (next_pre_wave_pause &gt; 0 || current_wave_number == final_wave) {</span>
<span class="pc bpc" id="L221" title="1 of 6 branches missed.">                if (duration &gt;= 0 &amp;&amp; frame_track == 0 &amp;&amp; monsters_to_spawn.size() &gt; 0 ) { //logic to make sure monsters are spawned at the correct increments</span>
<span class="fc" id="L222">                    randomMonsterSpawn(monsters_to_spawn, spawned_monsters);</span>
                }

<span class="fc bfc" id="L225" title="All 2 branches covered.">                for (Monsters current : spawned_monsters) {</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">                    if (ff.isSelected()) {</span>
<span class="nc" id="L227">                        current.speedup();</span>
                    }
                    else {
<span class="fc" id="L230">                        current.slowdown();</span>
                    }
                    
<span class="fc bfc" id="L233" title="All 4 branches covered.">                    if (current.isAlive() &amp;&amp; !current.getRespawn()) {  </span>
<span class="fc" id="L234">                        current.draw(app); </span>
<span class="fc" id="L235">                        current.move();</span>
<span class="fc" id="L236">                        current.respawnMonster(mana);</span>
                    }
<span class="fc bfc" id="L238" title="All 2 branches covered.">                    else if (!current.isAlive()) {  </span>
<span class="fc" id="L239">                        total_monsters_current_wave--; </span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">                        if (current.disappeared()) {</span>
<span class="fc" id="L241">                            to_remove.add(current);</span>
<span class="fc" id="L242">                            total_monsters--;</span>
                        }
                        else {
<span class="fc" id="L245">                            current.draw(app);</span>
<span class="fc" id="L246">                            current.deathAnimation(app, ff); </span>
                        }
                    }
<span class="pc bpc" id="L249" title="3 of 6 branches missed.">                    else if (current.isAlive() &amp;&amp; current.getRespawn() &amp;&amp; frame_track == 0) {</span>
<span class="fc" id="L250">                        current.setRespawn();</span>
                    }
                                        
<span class="fc" id="L253">                }</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">                for (Monsters remove: to_remove) {</span>
<span class="fc" id="L255">                    spawned_monsters.remove(remove);</span>
<span class="fc" id="L256">                }</span>
            } 
<span class="pc bpc" id="L258" title="2 of 4 branches missed.">            else if (duration == 0 &amp;&amp; next_pre_wave_pause == 0) {</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">                if (current_wave_number &lt; final_wave) {</span>
<span class="fc" id="L260">                    current_wave_number++;</span>
<span class="fc" id="L261">                    newWave(app);    </span>
                }
            }
<span class="fc" id="L264">        }</span>
        else {
<span class="fc bfc" id="L266" title="All 2 branches covered.">            for (Monsters current : spawned_monsters) {</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">                if (!current.disappeared()) {</span>
<span class="fc" id="L268">                    current.draw(app);</span>
                }
<span class="fc" id="L270">            }    </span>
        }
<span class="fc" id="L272">    }</span>
    
    /**
     * Renders the next wave text on screen
     * @param app that instantiates the class
     */
    public void draw(PApplet app) {
<span class="fc" id="L279">        this.next_wave_text.draw(app);</span>
<span class="fc" id="L280">    }</span>

    /**
     * Indicates whether the game has been won yet or not
     * @return has_won; true if all monsters have been killed after the final wave begins, false otherwise
     */
    public boolean hasWon() {
<span class="fc" id="L287">        return has_won;</span>
    }

    /**
     * Allows the user to start a new wave by re-initialising the wave attributes for the next wave. 
     * This method should be invoked when the player has not yet reached the final wave and the duration of the current wave has ended with mana still remaining
     * @param app that instantiates the class
     */
    private void newWave(PApplet app) {
<span class="fc" id="L296">        current_wave = getCurrentWave(waves, current_wave_number);</span>
<span class="fc" id="L297">        duration = getNumericAmount(&quot;duration&quot;, current_wave);</span>
<span class="fc" id="L298">        total_monsters_current_wave = getTotalMonsters(readJSONArray(current_wave, &quot;monsters&quot;));</span>
<span class="fc" id="L299">        total_monsters += total_monsters_current_wave;</span>
        
<span class="fc" id="L301">        monster_types = getMonsterTypes(readJSONArray(current_wave, &quot;monsters&quot;));</span>
<span class="fc" id="L302">        frames_per_spawn = setFramesPerSpawn(FPS);</span>
<span class="fc" id="L303">        double_frames = setFramesPerSpawn(FPS/2);</span>
<span class="fc" id="L304">        monsters_to_spawn = getMonstersToSpawn(types, board);</span>

<span class="fc bfc" id="L306" title="All 2 branches covered.">        if (current_wave_number &lt; final_wave) {</span>
<span class="fc" id="L307">            next_pre_wave_pause = getNumericAmount(&quot;pre_wave_pause&quot;, getCurrentWave(waves, current_wave_number + 1));</span>
        }
        else {
<span class="fc" id="L310">            next_pre_wave_pause = 0;</span>
        }
<span class="fc" id="L312">        next_wave_text.setNextWave();</span>
<span class="fc" id="L313">        next_wave_text.setSeconds((int)next_pre_wave_pause + (int)duration);</span>
<span class="fc" id="L314">    }</span>

    /**
     * Renders the text that indicates the end of the game and whether the player has won or lost. 
     * The text to display depends on whether the player has killed all monsters to spawn for each wave and whether they have mana remaining
     * @param app that instantiates this class
     */
    public void displayWin(PApplet app) {
<span class="fc" id="L322">        String to_print = &quot;&quot;;</span>
        int[] colour;
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">        if (has_won) {</span>
<span class="nc" id="L325">            to_print = &quot;YOU WIN&quot;;</span>
<span class="nc" id="L326">            colour = new int[]{255, 255, 255};</span>
        }
<span class="fc bfc" id="L328" title="All 2 branches covered.">        else if (mana.hasLost()) {</span>
<span class="fc" id="L329">            to_print = &quot;YOU LOST&quot;;</span>
<span class="fc" id="L330">            colour = new int[]{0, 0, 0};</span>
        }
        else {
<span class="fc" id="L333">            return;</span>
        }

<span class="fc" id="L336">        app.fill(colour[0], colour[1], colour[2]);</span>
<span class="fc" id="L337">        app.textSize(150);</span>
<span class="fc" id="L338">        app.textAlign(PApplet.CENTER, PApplet.CENTER);</span>
<span class="fc" id="L339">        app.text(to_print, 760/2, 680/2-50);</span>

<span class="fc" id="L341">        app.textSize(40);</span>
<span class="fc" id="L342">        app.text(&quot;Press 'r' to restart&quot;, 760/2, 680/2+50);</span>
<span class="fc" id="L343">    }</span>

    /**
     * For testing purposes to check the functionality tick() method; sets pre_wave_pause to 0.
     */
    public void setPreWavePauseZero() {
<span class="fc" id="L349">        pre_wave_pause = 0;</span>
<span class="fc" id="L350">    }</span>

    /**
     * For testing purposes to check the functionality tick() method; sets duration to 0.
     */
    public void setDurationZero() {
<span class="fc" id="L356">        duration = 0;</span>
<span class="fc" id="L357">    }</span>

    /**
     * For testing purposes to check the functionality tick() method; sets bext_pre_wave_pause to 0.
     */
    public void setNextPreWavePauseZero() {
<span class="fc" id="L363">        next_pre_wave_pause = 0;</span>
<span class="fc" id="L364">    }</span>

    /**
     * For testing purposes to check the functionality tick() method; sets total_monsters to 0.
     */
    public void setTotalMonstersZero() {
<span class="fc" id="L370">        total_monsters = 0;</span>
<span class="fc" id="L371">    }</span>

    /**
     * Retrieves the current wave number.
     * @return current_wave_number
     */
    public int getCurrentWaveNumber() {
<span class="fc" id="L378">        return current_wave_number;</span>
    }

    /**
     * Retrieves the current wave framecount, which increments every time the tick() method is called and the game has not ended or been paused
     * @return wave_framecount
     */
    public int getWaveFrameCount() {
<span class="fc" id="L386">        return wave_framecount;</span>
    }



}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>